/* vim: set syntax=magma : */
/*
*/

    AttachSpec("~/AbVarFq/spec");


    AttachSpec("~/AlgEt/spec");
    Attach("PrimesAttributes.m");
    Attach("DieudonneModules.m");
    Attach("IsomorphismClasses.m");
    Attach("SaveLoad.m");

    PP<x>:=PolynomialRing(Integers());

    fld:="~/IsomClassesAbVarFqComEnd/parallel_storing/output/";
    input_ls:=Pipe("ls " cat fld,"");
    file:="4.4.b_b_e_ae";
    str:=Read(fld cat file);
    iso:=load_isom_classes(str);
    R:=Order(iso[1,1]);
    m0,J,dJ,Q,mQ,F,V:=Explode(R`SemilinearOperators);
    E:=Algebra(R);
    h:=DefiningPolynomial(E);
    assert IsSquarefree(h);
    q:=Round(ConstantCoefficient(h)^(2/Degree(h)));
    t,p,a:=IsPrimePower(q); assert t;

    oo:=OverOrders(R);
    OE:=MaximalOrder(E);
    ind:=[Index(OE,S):S in oo];
    ParallelSort(~ind,~oo);
    Reverse(~oo);
    ends:={@ X[4] : X in iso @};
    for iS->S in oo do
        dmS:={@ X[2] : X in iso | X[4] eq S @};
        // a-numbers
        a_nums:=[];
        for M in dms do
            assert M subset J;
            M:=sub<Q|[mQ(z):z in ZBasis(M)]>;
            FM:=sub<M|[M!F(M.i):i in [1..Ngens(M)]]>;
            VM:=sub<M|[M!V(M.i):i in [1..Ngens(M)]]>;
            Append(~a_nums,Ilog(q,Index(M,FM+VM)));
        end for;
        // indices of minimal overorders (to find the place of S in the graph of inclusions)
        ind_min_oo:=[ Index(oo,T) : T in MinimalOverOrders(S) ];
        printf "%o,%o,%o,%o,%o,%o\n",iS,Index(OE,S),#dmS,#PicardGroup(S),a_nums,ind_min_oo;
    end for;

/*

*/

























