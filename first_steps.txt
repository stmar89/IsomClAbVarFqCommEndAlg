/* vim: set syntax=magma : */
/*
    TODO
    - Add references to the paper (scan for ADDREF, some might be missing)
    - 'Duality', i.e. the induced complex conjugation on A, allow us to compute only for place with slope <= 1/2.
        Need to implement it.
*/

    AttachSpec("~/AlgEt/spec");
   
    _<x>:=PolynomialRing(Integers());
    //h:=( 16 - 4*x + x^2 )*( 256 - 112*x + 40*x^2 - 7*x^3 + x^4 ); // 3.16.al_dg_aou, Dimension(A) = 48
    //h:=( 4 - 2*x + x^2 )*( 16 - 4*x + 4 *x^2 - x^3 + x^4); // 3.4.ad_k_aq, Dimension(A) = 12
    h:=( 16 - 4*x + 4 *x^2 - x^3 + x^4); // Dimension(A) = 12

    g:=Degree(h) div 2;
    q:=Truncate(ConstantCoefficient(h)^(1/g));
    t,p,a:=IsPrimePower(q);
    assert t; delete t;

    E:=EtaleAlgebra(h);
    pi:=PrimitiveElement(E);
    R:=Order([pi,q/pi]);
    O:=MaximalOrder(E);
    indOR:=Index(O,R);
    vp_indOR:=Valuation(indOR,p);

    slope_E:=function(P)
    // given a prime of R returns the slope of P
    // see beginning of 4.3.1, for the definition
    // TODO we should store the slope of P, mm and all other primes above P
        O:=MaximalOrder(Algebra(P));
        pp:=PrimesAbove(O!!P);
        mm:=pp[1];
        _,comp:=IsProductOfIdeals(mm);
        ind:=[ i : i in [1..#comp] | not NumberField(Order(comp[i]))!1 in comp[i] ];
        assert #ind eq 1;
        ind:=ind[1];
        mm:=comp[ind];
        pi_ind:=Components(pi)[ind];
        val_pi:=Valuation(pi_ind,mm);
        e_mm:=RamificationIndex(mm);
        return val_pi/(a*e_mm);
    end function;

    // we separate the singular primes of R into 4 sets:
    // above ell\neq p; slope 0; slope in (0,1); slope 1.
    sing:=SingularPrimes(R);
    sing_ell:=[];
    sing_0:=[];
    sing_1:=[];
    for P in sing do
        ind:=Index(R,P);
        if IsCoprime(ind,p) then
            Append(~sing_ell,P);
        else
            sP:=slope_E(P);
            if sP eq 0 then
                Append(~sing_0,P);
            elif sP eq 1 then
                Append(~sing_1,P);
            end if;
        end if;
    end for;

    // ################### 
    // we compute the isomorphism classes of the part at ell\neq p, slope 0 and slope 1;
    // recall that these 3 parts can be done using R ideals: no need to extend;
    // ell-Tate-Modules
    part_ell:=[];
    for ell in sing_ell do
        l:=MinimalInteger(ell);
        assert IsPrime(l);
        vl:=Valuation(indOR,l);
        R_ell:=Order( ZBasis(R) cat ZBasis(ell^vl*O) );
        Append(~part_ell, [ R!!I : I in WKICM(R_ell) ]);
    end for;

    // slope 0 and 1
    part_0:=[];
    part_1:=[];
    for P in sing_0 do
        R_P:=Order( ZBasis(R) cat ZBasis(O!!P^vp_indOR));
        Append(~part_0, [ R!!I : I in WKICM(R_P) ]);
        Append(~part_1, [ R!!ComplexConjugate(I) : I in WKICM(R_P) ]);
    end for;

    // ################### 
    // Global Representatives: tilde A, tilde W_R, etc . 
    // I dropped the tilde from the notation...I don't hate my life enough.
    // ################### 
    L<zeta>:=CyclotomicField(q-1);
    sigma_L:=hom< L->L | [ zeta^p ] >; //does not have inverse
    assert sigma_L(2) eq 2;
    OL:=MaximalOrder(L);
    zb_OL:=Basis(OL);

    fac_h_L:=Factorization( PolynomialRing(L) ! h );
    assert forall{ g : g in fac_h_L| g[2] eq 1 };
    nfs_A:=[ NumberField(g[1]) : g in fac_h_L ];
    nfs_A_abs:=[ AbsoluteField(nf) : nf in nfs_A ];

    // A: an etale algrebra over Q. isomorphic to L \otimes E
    A:=EtaleAlgebra(nfs_A_abs);
    _,embs_A,proj_A:=Components(A);

    OA:=MaximalOrder(A);

    // pi in A
    pi_A_comps:=<  >;
    for i in [1..#nfs_A] do
        test,pi_i:=HasRoot(fac_h_L[i][1],nfs_A[i]);
        assert test;
        pi_i:=nfs_A_abs[i]!pi_i;
        Append(~pi_A_comps,pi_i);
    end for;
    pi_A:=A!pi_A_comps;
    assert MinimalPolynomial(pi_A) eq h;
    pows_pi_A:=[ pi_A^i : i in [0..Dimension(E)-1 ]];

    // Delta E \to A, the natural embedding
    Delta_map:=map< E->A | z:->SumOfProducts(AbsoluteCoordinates([z],PowerBasis(E))[1],pows_pi_A) >;

    // tilde sigma: acts as zeta:->zeta^q on each compoenent of A
    sigma_image:=function(x)
        x_comp:=Components(x);
        N:=#x_comp;
        img:=<>;
        for i in [1..N] do
            BL:=nfs_A[i]; // nf over L
            BQ:=nfs_A_abs[i]; // nf over Q
            assert x_comp[i] eq BQ!(BL!Eltseq(BL!x_comp[i]));
            img_i:=BQ!(BL![ sigma_L(c) : c in Eltseq(BL!x_comp[i])]);
            Append(~img,img_i);
        end for;
        return A!img;
    end function;
    // TODO add inverse
    sigma:=map< A-> A | x:->sigma_image(x) >; //does not have inverse
    assert forall{ x : x in [ Delta_map(y) : y in ZBasis(MaximalOrder(E))] | x eq sigma(x) };

    // tilde W_R: order isomorphic to W \otimes R
    gens_WR:=&cat[ [ embs_A[i](nfs_A_abs[i]!z*pi_A_comps[i]) , //z*pi
                     embs_A[i](nfs_A_abs[i]!z*q/pi_A_comps[i]) ] : i in [1..#nfs_A], //z*q/pi
                     z in zb_OL ]; //OL=W
    WR:=Order(gens_WR);

    // test
    // TODO CHECKME:
        assert pi_A in WR;
        assert q/pi_A in WR;
        CohenMacaulayType(WR); //I was expecting 1... is this right?
        zbOEinA:=[ Delta_map(g) : g in ZBasis(MaximalOrder(E)) ];
        gens_max:=[ embs_A[i](nfs_A_abs[i]!z*Components(g)[i]) 
                           : i in [1..#nfs_A], z in zb_OL , g in zbOEinA ];
        assert IsMaximal(Order(gens_max));
        time _:=MaximalOrder(A);
        time _:=IsMaximal(WR);
    // end test...it looks good

    primes_of_A_above_place_of_E:=function(A,P)
    // given a maximal ideal P of OE returns the maximal ideals of OA above P
        OA:=MaximalOrder(A);
        return PrimesAbove(Ideal(OA,[ Delta_map(z) : z in ZBasis(P)]));
    end function;
    
    primes_of_S_above_place_of_E:=function(S,P)
    // given a maximal ideal P of OE and an order S of A returns the maximal ideals of S above P
        oneS:=OneIdeal(S);
        A:=Algebra(S);
        pp:=primes_of_A_above_place_of_E(A,P);
        pp:=[ oneS meet (S!!P) : P in pp ];
        return Setseq(Seqset(&cat[PrimesAbove(P) : P in pp ]));
    end function;

    places_01_E:=function(E)
    // returns the places of E_p of slope in (0,1)
        return [ P : P in PrimesAbove(p*MaximalOrder(E)) | 0 lt sp and sp lt 1 where sp:=slope_E(P) ]; 
    end function;

    //////////////////
    // Units quotient
    //////////////////
    // Let S be an order in A', containing R'. We want to compute OA'^*/S^*\Delta'(O_E'^*)

    units_quotient_P:=function(S,P)
    // Given an order S in A and a prime P of S, it computes U:=O_{A,P}^*/S_P^*,
    // where OA is the maximal order of A, together with map u:U->OA
    // This is based on Lemma ADDREF
        assert Order(P) eq S;
        if IsInvertible(P) then
            // early exit: in this case S is P-maximal, that is, O_{A,P} = S_P.
            U:=AbelianGroup([1]); //trivial groups
            A:=Algebra(S);
            u:=map<U->A | x:->One(A), y:->Zero(U) >; //trivial map
            return U,u;
        end if;


        q:=Index(S,P);
        t,p:=IsPrimePower(q);
        assert t; delete t; delete q;
        OA:=MaximalOrder(Algebra(S));
        ff:=Conductor(S);
        ffOA:=OA!!ff;
        pp_OA:=PrimesAbove(OA!!P);
        Us:=[];
        us:=[];
        for PP in pp_OA do
            M:=Valuation(Index(OA,ffOA),p); // PP^M c ff locally at PP
            U,u:=ResidueRingUnits(OA,ffOA+PP^M); // u: U=(OA/ff+PP^M)^* -> OA
            Append(~Us,U);
            Append(~us,u);
        end for;
        n:=#pp_OA;
        D_OA,embs,projs:=DirectSum(Us);
        d_OA:=map< D_OA->Algebra(OA) |  x:->&*[ us[i](projs[i](x)) : i in [1..n] ],
                                        y:->&+[ embs[i](y@@us[i]) : i in [1..n] ] >;
        
        m:=Valuation(Index(S,ff),p); // P^m c ff locally at P
        ffPm:=ff+P^m;
        assert not 1 in ffPm;
        gens:=ResidueRingUnitsSubgroupGenerators(ffPm);
            // gens is a set of generators of (S/ff+P^m)^* = (S_P/ff_P)^* in A.
        U,u0:=quo<D_OA | [ g@@d_OA : g in gens ]>; // u0:D_OA->U
        u:=map<U->Algebra(OA) | x:->d_OA(x@@u0), y:->u0(y@@d_OA) >;
        assert forall{ g : g in Generators(U) | (u(g))@@u eq g};
        return U,u;
    end function;

    units_quotient_01:=function(S)
    // Given an order S in A, representing an order S' in A' returns U=OA'^*/S'^* and a map u:U->OA
        primes_01_S:=&cat[ primes_of_S_above_place_of_E(S,P) : P in places_01_E(E)];
        Us:=[];
        us:=[];
        for P in primes_01_S do
            U,u:=units_quotient_P(S,P);
            Append(~Us,U);
            Append(~us,u);
        end for;
        n:=#primes_01_S;
        U,embs,projs:=DirectSum(Us);
        u:=map<U->Algebra(S) |  x:->&*[ us[i](projs[i](x)) : i in [1..n] ],
                                y:->&+[ embs[i](y@@us[i]) : i in [1..n] ] >;
        assert forall{ g : g in Generators(U) | (u(g))@@u eq g};
        return U,u;
    end function;

    fixed_pts_sigma:=function(S,sigma)
    // Given an order S in A, representing an order S' in A', 
    // which is stable by the action of sigma (eg. WR),
    // returns U,u,F where
    // U=OA'^*/S'^*,
    // u is a map u:U->OA giving representatives 
    // F is the subgroup of elements of U=OA'^*/S'^* fixed by sigma
        U,u:=units_quotient_01(S); //u:U->A
        Ugens_inA:=[ u(U.i) : i in [1..Ngens(U)] ];
        id_sigma:=hom< U->U | [ (x/sigma(x))@@u : x in Ugens_inA ]>;
        F:=Kernel(id_sigma);
        return U,u,F;
    end function;

    units_quotient_fixed_sigma_WR_gens:=function(WR,sigma)
    // only for WR
    // returns a set of generators in A of 
    // Q = OA'^*/W_R'^*Delta(OE'^*) 
        U,u,F:=fixed_pts_sigma(WR,sigma);
        Q,q0:=quo<U|F>; //q0: U->U/F=Q=OA'^*/WR'^*\Delta(OE'^*)
        gens_inA:=[u(Q.i@@q0) : i in [1..Ngens(Q)]];
        //TODO this should be cached, and maybe this shouldn't be a function
        return gens_inA;
    end function;

    units_quotient_fixed_sigma:=function(S,sigma)
    // Given an order S in A, representing an order S' in A', returns Q,q where
    // Q = OA'^*/S'^*Delta(OE'^*) 
    // q is a map Q->OA giving representatives
        U,u:=units_quotient_01(S); //u:U=OA'^*/S'^* -> A
        fixed_pts_gens:=[ g@@u : g in units_quotient_fixed_sigma_WR_gens(WR,sigma)];
        Q,q0:=quo<U|fixed_pts_gens>; //q0: U->U/F=Q
        q:=map<Q->Algebra(S) |  x:->u(x@@q0), y:->q0(y@@u) >;
        return Q,q;
    end function;

    // TEST
    oo:=OverOrders(WR);
    for iS->S in oo do
        iS;
        _:=units_quotient_fixed_sigma(S,sigma);
    end for;


    //TODO 
    // - the following 3 functions should be intrinsics. 
    // - using the build it intrinsics for number fields is probably faster (maybe they use p-adics factorizations); 
    // - everything should be cached as attributs.
    inertia_degree:=function(P)
        q:=Index(Order(P),P);
        t,p,f:=IsPrimePower(q);
        assert t;
        return f;
    end function;

    valuation_elt:=function(x,P)
    // only for x in Order(P) = Maximal
        fac:=Factorization(x*Order(P));
        pps:=[ g[1] : g in fac ];
        ind:=Index(pps,P);
        assert (ind ne 0) eq (x in P);
        return fac[ind][2];
    end function;
    
    valuation_idl:=function(J,P)
    // Order(J) = Order(P) = Maximal
        assert J subset Order(J);
        if One(Algebra(J)) in J then 
            return 0;
        end if;
        fac:=Factorization(J);
        pps:=[ g[1] : g in fac ];
        ind:=Index(pps,P);
        assert (ind ne 0) eq (J subset P);
        return fac[ind][2];
    end function;

    ramification_index:=function(P)
        q:=Index(Order(P),P);
        t,p:=IsPrimePower(q);
        assert t;
        return valuation_elt(p,P);
    end function;

    exponents_from_Waterhouse:=function(P)
    // Use Proposition~\ref{prop:FVstable_OO} to compute up to $\Delta'$-isomorphism all $W'\{F,V\}$-ideals $J_1,\ldots,J_m$ having maximal multiplicator ring $\OO_{A'}$, each $J_j$ given as tuples of vectors of the form $(t_\nu^{\varepsilon_{j,\nu,1}},\ldots, t_\nu^{\varepsilon_{j,\nu,g_\nu}})_\nu$.
    // For each place $\nu$, consider the set $\chi_\nu$ all ordered $g_\nu$-tuples
    // \[ 0\leq n_1 \leq \ldots \leq n_{g_\nu}\leq e_\nu \]
    // such that
    // \[ \sum_{i=1}^{g_\nu} n_i = \frac{g_{\nu} \val_\nu(\pi_\nu)}{a}. \]
    // For each such tuple, set $\varepsilon_1=0$ and $\varepsilon_i=\varepsilon_{i-1}+n_{i-1}$, for $i=2,\ldots,g_\nu$.
        f_nu:=inertia_degree(P);
        g_nu:=GCD(a,f_nu); //q=p^a
        e_nu:=ramification_index(P);
        exps:=[];
        // this is naive.
        cp:=CartesianProduct([ [0..e_nu] : i in [1..g_nu]]);
        for tup0 in cp do
            tup:=[ tup0[i] : i in [1..g_nu] ];
            if forall{ i : i in [1..g_nu-1] | tup[i] le tup[i+1] } and 
                &+tup eq Integers()!(g_nu*valuation_elt(pi,P)/a) then
                exp:=[ i eq 1 select 0 else $$[i-1] + tup[i-1] : i in [1..g_nu]];
                Append(~exps,exp);
            end if;
        end for;
        return exps;
    end function;
    
    // ####################
    // Algorithm 2
    // ####################

    nice_uniformizers:=function(PPAs)
    // given the list of maximal ideals of A, it returns a seqence of elements t_P in A such that 
    // t_P is a uniformizer of P and a unit at every Q\neq P
        A:=Algebra(PPAs[1]);
        PPAs:=[ P^2 : P in PPAs ];
        one:=One(A);
        nice_unifs:=[];
        for iP->P in PPAs do
            Q,q:=Quotient(P,P^2);
            repeat
                t:=Random(Q);
            until t ne Zero(Q);
            tP:=t@@q;
            if #PPAs gt 1 then
                elts:=[ i eq iP select tP else one : i in [1..#PPAs] ];
                tP:=CRT(PPAs,elts);
            end if;
            Append(~nice_unifs,tP);
        end for;
        return nice_unifs;
    end function;

    // We compute the W'_R-isomorpshim classes of W'_R-ideals.
    exps_nus:=[];
    pp_A_nus:=[];
    for P in places_01_E(E) do
        Append(~exps_nus,exponents_from_Waterhouse(P));
        Append(~pp_A_nus,primes_of_A_above_place_of_E(A,P));
    end for;
    exps_nus_cc:=CartesianProduct(exps_nus);
    exps_01:=[];
    for cc in exps_nus_cc do
        Append(~exps_01,&cat[ c : c in cc ]); 
    end for;
    pp_A_01:=&cat(pp_A_nus);
    nice_unifs_01:=nice_uniformizers(pp_A_01);
    k:=Valuation(Index(OA,WR),p);
    WR_01:=Order( ZBasis(WR) cat ZBasis(OA!!&*[ P^k : P in pp_A_01 ]));
    // this order is locally isomorphic to WR' at every place of slope 01
    wk_01:=WKICM(WR_01);

    WR_01_idls_with_ext_i_to_OA_F_V_stable:=[];
    for I in wk_01 do
        S:=MultiplicatorRing(I);
        J:=OA!!I;
        valsJ:=[ valuation_idl(J,P) : P in pp_A_01 ];
        deltas:=[];
        for exps in exps_01 do
            assert #exps eq #pp_A_01; 
            Append(~deltas,&*[nice_unifs_01[i]^(valsJ[i]-exps[i]) : i in [1..#pp_A_01]]);
        end for;
        // the following two lines should be cached
        QS,qS:=units_quotient_fixed_sigma(S,sigma);
        gammas:=[ qS(x) : x in QS ];

        II:=[ d*g*I : d in deltas, g in gammas ];
        WR_01_idls_with_ext_i_to_OA_F_V_stable cat:=II;
    end for;

    #WR_01_idls_with_ext_i_to_OA_F_V_stable;

