/* vim: set syntax=magma : */
/*
    TODO
    Add references to the paper (scan for ADDREF, some might be missing)
*/

    AttachSpec("~/AlgEt/spec");
   
    _<x>:=PolynomialRing(Integers());
    //h:=( 16 - 4*x + x^2 )*( 256 - 112*x + 40*x^2 - 7*x^3 + x^4 ); // 3.16.al_dg_aou, Dimension(A) = 48
    //h:=( 4 - 2*x + x^2 )*( 16 - 4*x + 4 *x^2 - x^3 + x^4); // 3.4.ad_k_aq, Dimension(A) = 12
    h:=( 16 - 4*x + 4 *x^2 - x^3 + x^4); // Dimension(A) = 12

    g:=Degree(h) div 2;
    q:=Truncate(ConstantCoefficient(h)^(1/g));
    t,p,a:=IsPrimePower(q);
    assert t; delete t;

    E:=EtaleAlgebra(h);
    pi:=PrimitiveElement(E);
    R:=Order([pi,q/pi]);
    O:=MaximalOrder(E);
    indOR:=Index(O,R);
    vp_indOR:=Valuation(indOR,p);

    slope_E:=function(P)
    // given a prime of R returns the slope of P
    // see beginning of 4.3.1, for the definition
    // TODO we should store the slope of P, mm and all other primes above P
        O:=MaximalOrder(Algebra(P));
        pp:=PrimesAbove(O!!P);
        mm:=pp[1];
        _,comp:=IsProductOfIdeals(mm);
        ind:=[ i : i in [1..#comp] | not NumberField(Order(comp[i]))!1 in comp[i] ];
        assert #ind eq 1;
        ind:=ind[1];
        mm:=comp[ind];
        pi_ind:=Components(pi)[ind];
        val_pi:=Valuation(pi_ind,mm);
        e_mm:=RamificationIndex(mm);
        return val_pi/(a*e_mm);
    end function;

    // we separate the singular primes of R into 4 sets:
    // above ell\neq p; slope 0; slope in (0,1); slope 1.
    sing:=SingularPrimes(R);
    sing_ell:=[];
    sing_0:=[];
    sing_01:=[];
    sing_1:=[];
    for P in sing do
        ind:=Index(R,P);
        if IsCoprime(ind,p) then
            Append(~sing_ell,P);
        else
            sP:=slope_E(P);
            if sP eq 0 then
                Append(~sing_0,P);
            elif sP eq 1 then
                Append(~sing_1,P);
            else
                assert 0 lt sP and sP lt 1;
                Append(~sing_01,P);
            end if;
        end if;
    end for;

    // ################### 
    // we compute the isomorphism classes of the part at ell\neq p, slope 0 and slope 1;
    // recall that these 3 parts can be done using R ideals: no need to extend;
    // ell-Tate-Modules
    part_ell:=[];
    for ell in sing_ell do
        l:=MinimalInteger(ell);
        assert IsPrime(l);
        vl:=Valuation(indOR,l);
        R_ell:=Order( ZBasis(R) cat ZBasis(ell^vl*O) );
        Append(~part_ell, [ R!!I : I in WKICM(R_ell) ]);
    end for;

    // slope 0
    part_0:=[];
    for P in sing_0 do
        R_P:=Order( ZBasis(R) cat ZBasis(O!!P^vp_indOR));
        Append(~part_0, [ R!!I : I in WKICM(R_P) ]);
    end for;

    // slope 1
    part_1:=[];
    for P in sing_1 do
        R_P:=Order( ZBasis(R) cat ZBasis(O!!P^vp_indOR));
        Append(~part_1, [ R!!I : I in WKICM(R_P) ]);
    end for;
  
    // ################### 
    // Global Representatives: tilde A, tilde W_R, etc . 
    // I dropped the tilde from the notation...I don't hate my life enough.
    // ################### 
    L<zeta>:=CyclotomicField(q-1);
    sigma_L:=hom< L->L | [ zeta^p ] >; //does not have inverse
    assert sigma_L(2) eq 2;
    OL:=MaximalOrder(L);
    zb_OL:=Basis(OL);

    fac_h_L:=Factorization( PolynomialRing(L) ! h );
    assert forall{ g : g in fac_h_L| g[2] eq 1 };
    nfs_A:=[ NumberField(g[1]) : g in fac_h_L ];
    nfs_A_abs:=[ AbsoluteField(nf) : nf in nfs_A ];

    // A: an etale algrebra over Q. isomorphic to L \otimes E
    A:=EtaleAlgebra(nfs_A_abs);
    _,embs_A,proj_A:=Components(A);

    // pi in A
    pi_A_comps:=<  >;
    for i in [1..#nfs_A] do
        test,pi_i:=HasRoot(fac_h_L[i][1],nfs_A[i]);
        assert test;
        pi_i:=nfs_A_abs[i]!pi_i;
        Append(~pi_A_comps,pi_i);
    end for;
    pi_A:=A!pi_A_comps;
    assert MinimalPolynomial(pi_A) eq h;
    pows_pi_A:=[ pi_A^i : i in [0..Dimension(E)-1 ]];

    // Delta E \to A, the natural embedding
    Delta_map:=map< E->A | z:->SumOfProducts(AbsoluteCoordinates([z],PowerBasis(E))[1],pows_pi_A) >;

    // tilde sigma: acts as zeta:->zeta^q on each compoenent of A
    sigma_image:=function(x)
        x_comp:=Components(x);
        N:=#x_comp;
        img:=<>;
        for i in [1..N] do
            BL:=nfs_A[i]; // nf over L
            BQ:=nfs_A_abs[i]; // nf over Q
            assert x_comp[i] eq BQ!(BL!Eltseq(BL!x_comp[i]));
            img_i:=BQ!(BL![ sigma_L(c) : c in Eltseq(BL!x_comp[i])]);
            Append(~img,img_i);
        end for;
        return A!img;
    end function;
    // TODO add inverse
    sigma:=map< A-> A | x:->sigma_image(x) >; //does not have inverse
    assert forall{ x : x in [ Delta_map(y) : y in ZBasis(MaximalOrder(E))] | x eq sigma(x) };

    // tilde W_R: order isomorphic to W \otimes R
    gens_WR:=&cat[ [ embs_A[i](nfs_A_abs[i]!z*pi_A_comps[i]) , 
                     embs_A[i](nfs_A_abs[i]!z*q/pi_A_comps[i]) ]
                       : i in [1..#nfs_A], z in zb_OL ];
    time WR:=Order( gens_WR );   
    assert pi_A in WR;
    assert q/pi_A in WR;
    // TODO CHECKME:
        CohenMacaulayType(WR); //I was expecting 1... is this right?
    // test
        zbOEinA:=[ Delta_map(g) : g in ZBasis(MaximalOrder(E)) ];
        gens_max:=[ embs_A[i](nfs_A_abs[i]!z*Components(g)[i]) 
                           : i in [1..#nfs_A], z in zb_OL , g in zbOEinA ];
        assert IsMaximal(Order(gens_max));
        time _:=MaximalOrder(A);
        time _:=IsMaximal(WR);
    // end test...it looks good


    // now we starting working on the part with slope in (0,1)
    // Step 1: W'_R-isomorphism classes.
    O_A:=MaximalOrder(A);

//    // how do I find the primes of slope in (0,1);
//    slope_A:=function(P)
//    // given a prime of WR returns the slope of P
//    // see beginning of 4.3.1, for the definition
//    // TODO we should store the slope of P, mm and all other primes above P
//        O:=MaximalOrder(Algebra(P));
//        pp:=PrimesAbove(O!!P);
//        mm:=pp[1];
//        _,comp:=IsProductOfIdeals(mm);
//        ind:=[ i : i in [1..#comp] | not NumberField(Order(comp[i]))!1 in comp[i] ];
//        assert #ind eq 1;
//        ind:=ind[1];
//        mm:=comp[ind];
//        pi_ind:=Components(pi_A)[ind];
//        val_pi:=Valuation(pi_ind,mm);
//        e_mm:=RamificationIndex(mm);
//        return val_pi/(a*e_mm);
//    end function;

    primes_of_A_above_place_of_E:=function(A,P)
    // given a maximal ideal P of OE returns the maximal ideals of OA above P
        OA:=MaximalOrder(A);
        return PrimesAbove(Ideal(OA,[ Delta_map(z) : z in ZBasis(P)]));
    end function;
    
    primes_of_S_above_place_of_E:=function(S,P)
    // given a maximal ideal P of OE and an order S of A returns the maximal ideals of S above P
        oneS:=OneIdeal(S);
        A:=Algebra(S);
        pp:=primes_of_A_above_place_of_E(A,P);
        pp:=[ oneS meet (S!!P) : P in pp ];
        return Setseq(Seqset(&cat[PrimesAbove(P) : P in pp ]));
    end function;

    places_01_E:=function(E)
    // returns the places of E_p of slope in (0,1)
        return [ P : P in PrimesAbove(p*MaximalOrder(E)) | 0 lt sp and sp lt 1 where sp:=slope_E(P) ]; 
    end function;

    // We compute the W'_R-isomorpshim classes of W'_R-ideals.
    pp_01:=&cat[ primes_of_A_above_place_of_E(A,P) : P in places_01_E(E) ];
    k:=Valuation(Index(O_A,WR),p);
    part_01:=[];
    for P in pp_01 do
        WR_P:=Order( ZBasis(WR) cat ZBasis(O_A!!P^k));
        time wk:=WKICM(WR_P);
        Append(~part_01, [ WR!!I : I in wk ]);
    end for;

    //TODO 
    // - the following 3 functions should be intrinsics. 
    // - using the build it intrinsics for number fields is probably faster (maybe they use p-adics factorizations); 
    // - everything should be cached as attributs.
    inertia_degree:=function(P)
        q:=Index(Order(P),P);
        t,p,f:=IsPrimePower(q);
        assert t;
        return f;
    end function;

    valuation:=function(x,P)
    // only for x in Order(P)
        if not x in P then 
            return 0;
        end if;
        fac:=Factorization(x*Order(P));
        fac:=[ g[2] : g in fac | g[1] eq P ];
        assert #fac eq 1;
        return fac[1];
    end function;

    ramification_index:=function(P)
        q:=Index(Order(P),P);
        t,p:=IsPrimePower(q);
        assert t;
        return valuation(p,P);
    end function;
   


    exponents_from_Waterhouse:=function(P)
    // Use Proposition~\ref{prop:FVstable_OO} to compute up to $\Delta'$-isomorphism all $W'\{F,V\}$-ideals $J_1,\ldots,J_m$ having maximal multiplicator ring $\OO_{A'}$, each $J_j$ given as tuples of vectors of the form $(t_\nu^{\varepsilon_{j,\nu,1}},\ldots, t_\nu^{\varepsilon_{j,\nu,g_\nu}})_\nu$.
    // For each place $\nu$, consider the set $\chi_\nu$ all ordered $g_\nu$-tuples
    // \[ 0\leq n_1 \leq \ldots \leq n_{g_\nu}\leq e_\nu \]
    // such that
    // \[ \sum_{i=1}^{g_\nu} n_i = \frac{g_{\nu} \val_\nu(\pi_\nu)}{a}. \]
    // For each such tuple, set $\varepsilon_1=0$ and $\varepsilon_i=\varepsilon_{i-1}+n_{i-1}$, for $i=2,\ldots,g_\nu$.
        f_nu:=inertia_degree(P);
        g_nu:=GCD(a,f_nu); //q=p^a
        e_nu:=ramification_index(P);
        exps:=[];
        // this is naive.
        cp:=CartesianProduct([ [0..e_nu] : i in [1..g_nu]]);
        for tup0 in cp do
            tup:=[ tup0[i] : i in [1..g_nu] ];
            if forall{ i : i in [1..g_nu-1] | tup[i] le tup[i+1] } and 
                &+tup eq Integers()!(g_nu*valuation(pi,P)/a) then
                exp:=[ i eq 1 select 0 else $$[i-1] + tup[i-1] : i in [1..g_nu]];
                Append(~exps,exp);
            end if;
        end for;
        return exps;
    end function;
    //TODO test more

    //TEST
    for P in places_01_E(E) do
        exponents_from_Waterhouse(P);
    end for;
         
    //////////////////
    // Units quotient
    //////////////////
    // Let S be an order in A', containing R'. We want to compute O_A'^*/S^*\Delta'(O_E'^*)

    // copied from PicardGroup.m
    residue_class_ring_unit_subgroup_generators:=function(F)
    // determine generators of the subgroup of (S/F)^* as elements of A=Algebra(S)
        if not assigned F`residue_class_ring_unit_subgroup_generator then
            S:=Order(F);
            A:=Algebra(S);
            O:=MaximalOrder(A);
            Fm:=O!!F;
            l:=Factorization(Fm);
            l2:=[ <(S!!x[1]) meet S,x[2]>: x in l]; 
            primes:={x[1]:x in l2};
            primes:=[<x, Maximum([y[2]: y in l2 |y[1] eq x])>:x in primes];
            primes_powers:=[ p[1]^p[2] : p in primes ];
            elts:={};
            for i->a in primes do
                a1a2:=primes_powers[i];
                idp:=a[1];
                if #primes gt 1 then
                    rest:=&*[ primes_powers[j] : j in [1..#primes] | j ne i];
                else
                    rest:=OneIdeal(S);
                end if;
                //Compute primitive elt for residue field
                //c:=residue_class_field_primitive_element(idp);
                c:=PrimitiveElementResidueField(idp);
                e1:=ChineseRemainderTheorem(a1a2,rest,One(A),Zero(A));
                e2:=ChineseRemainderTheorem(a1a2,rest,Zero(A),One(A));
                c:=c*e1+e2;
                //c:=ChineseRemainderTheorem(a1a2,rest,c,One(A));
                assert2 c - ChineseRemainderTheorem(a1a2,rest,c,One(A)) in a1a2*rest;
                Include(~elts,c);
                b:=1;
                while b lt a[2] do
                    M:=ZBasis(idp);
                    M:=[1+x:x in M];
                    for elt in M do
                        c:=elt*e1+e2;
                        //c:=ChineseRemainderTheorem((a1a2),rest,elt,One(A));
                        assert2 c - ChineseRemainderTheorem(a1a2,rest,elt,One(A)) in a1a2*rest;
                        Include(~elts,c);
                    end for;
                    b:=b*2;
                    idp:=idp^2;
                end while;
            end for;
            assert2 forall{x : x in elts | x in S and not x in F};
            F`residue_class_ring_unit_subgroup_generator:=elts;
            vprintf AlgEtQPicardGroup, 2 :"residue_class_ring_unit_subgroup_generator:\n
                                             elts = %o\n",PrintSeqAlgEtQElt(Setseq(elts));
        end if;
        return F`residue_class_ring_unit_subgroup_generator ;
    end function;

    units_quotient_P:=function(S,P)
    // Given an order S in A and a prime P of S, it computes U:=O_{A,P}^*/S_P^*,
    // where O_A is the maximal order of A, together with map u:U->O_A
    // This is based on Lemma ADDREF
        q:=Index(S,P);
        t,p:=IsPrimePower(q);
        assert t; delete t; delete q;
        OA:=MaximalOrder(Algebra(S));
        ff:=Conductor(S);
        ffOA:=OA!!ff;
        pp_OA:=PrimesAbove(OA!!P);
        Us:=[];
        us:=[];
        for PP in pp_OA do
            M:=Valuation(Index(PP,ffOA),p); // PP^M c ff locally at PP
            U,u:=ResidueRingUnits(OA,ffOA+PP^M); // u: U=(O_A/ff+PP^M)^* -> O_A
            Append(~Us,U);
            Append(~us,u);
        end for;
        n:=#pp_OA;
        D_OA,embs,projs:=DirectSum(Us);
        d_OA:=map< D_OA->Algebra(OA) |  x:->&*[ us[i](projs[i](x)) : i in [1..n] ],
                                        y:->&+[ embs[i](y@@us[i]) : i in [1..n] ] >;
        
        m:=Valuation(Index(P,ff),p); // P^m c ff locally at P
        gens:=residue_class_ring_unit_subgroup_generators(ff+P^m);
            // gens is a set of generators of (S/ff+P^m)^* = (S_P/ff_P)^* in A.
        U,u0:=quo<D_OA | [ g@@d_OA : g in gens ]>; // u0:D_OA->U
        u:=map<U->Algebra(OA) | x:->d_OA(x@@u0), y:->u0(y@@d_OA) >;
        assert forall{ g : g in Generators(U) | (u(g))@@u eq g};
        return U,u;
    end function;

    units_quotient_01:=function(S)
    // Given an order S in A, representing an order S' in A' returns U=OA'^*/S'^* and a map u:U->OA
        primes_01_S:=&cat[ primes_of_S_above_place_of_E(S,P) : P in places_01_E(E)];
        Us:=[];
        us:=[];
        for P in primes_01_S do
            U,u:=units_quotient_P(S,P);
            Append(~Us,U);
            Append(~us,u);
        end for;
        n:=#primes_01_S;
        U,embs,projs:=DirectSum(Us);
        u:=map<U->Algebra(S) |  x:->&*[ us[i](projs[i](x)) : i in [1..n] ],
                                y:->&+[ embs[i](y@@us[i]) : i in [1..n] ] >;
        assert forall{ g : g in Generators(U) | (u(g))@@u eq g};
        return U,u;
    end function;

    fixed_pts_sigma:=function(S,sigma)
    // Given an order S in A, representing an order S' in A', returns U,u,F where
    // U=OA'^*/S'^*,
    // u is a map u:U->OA giving representatives 
    // F is the subgroup of elements of U=OA'^*/S'^* fixed by sigma
        U,u:=units_quotient_01(S); //u:U->A
        Ugens_inA:=[ u(U.i) : i in [1..Ngens(U)] ];
        id_sigma:=hom< U->U | [ (x/sigma(x))@@u : x in Ugens_inA ]>;
        F:=Kernel(id_sigma);
        return U,u,F;
    end function;

    units_quotient_fixed:=function(S,sigma)
    // Given an order S in A, representing an order S' in A', returns Q,q where
    // Q = OA'^*/S'^*Delta(OE'^*) 
    // q is a map Q->OA giving representatives
        U,u,F:=fixed_pts_sigma(S,sigma);
        Q,q0:=quo<U|F>; //q0: U->U/F=Q
        q:=map<U->Algebra(S) |  x:->u(x@@q), y:->q(y@@u) >;
        return Q,q;
    end function;

    // TEST
    /*
    P:=places_01_E(E)[1];
    P:=primes_of_S_above_place_of_E(WR,P)[1];
    units_quotient_P(WR,P);
    units_quotient_01(WR);
    units_quotient_fixed(WR,sigma);
    S:=WR;
    U,u:=units_quotient_01(S); //u:U->A
    [ u(x) : x in Generators(U) ];
    

    id_sigma:=hom< U->U | [ (x/sigma(x))@@u : x in [ u(x) : x in Generators(U)] ]>;
    F:=Kernel(id_sigma);
    F;
    */

    oo:=OverOrders(WR);
    for S in oo do
        Index(MaximalOrder(A),S);
        _:=units_quotient_fixed(S,sigma);
    end for;


